<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Event Hubs (Kafka) Metrics</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
      * { box-sizing: border-box; }
      html, body { height: 100%; }
      body { margin: 12px; overflow: hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial; color:#111; background:#fff; }

      .header { display:flex; align-items:end; justify-content:space-between; gap:8px; }
      h1 { margin: 0; font-size: 18px; font-weight: 700; }
      .muted { color:#666; font-size:12px; }

      .controls { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
      .controls input[type="time"] { padding:6px 8px; border:1px solid #ddd; border-radius:8px; font:inherit; }
      .btn { padding:6px 10px; border:1px solid #ddd; background:#fff; border-radius:8px; cursor:pointer; }
      .btn:hover { background:#f6f6f6; }
      .badge { font-size:12px; padding:4px 8px; border-radius:999px; border:1px solid #ddd; background:#fafafa; }

      .layout { height: 100%; display: grid; grid-template-rows: auto 1fr; gap: 8px; }
      :root { --top-h: 34vh; --bottom-h: 26vh; }
      .charts {
        display: grid;
        grid-template-rows: var(--top-h) var(--bottom-h);
        grid-template-columns: 1fr 1fr;
        gap: 8px;
        height: calc(100% - 0px);
      }
      .top-left   { grid-row: 1; grid-column: 1; }
      .top-right  { grid-row: 1; grid-column: 2; }
      .bottom     { grid-row: 2 / span 1; grid-column: 1 / span 2; }

      .card { border: 1px solid #e2e2e2; border-radius: 10px; padding: 8px; background:#fff; position: relative; height: 100%; display: flex; flex-direction: column; }
      .title { margin: 0 0 6px 0; font-size: 14px; font-weight: 700; }
      .wrap { flex: 1; min-height: 0; }
      .wrap canvas { width: 100%; height: 100%; display: block; }
      .status { position:absolute; top:8px; right:10px; font-size:11px; color:#666; }
      .status.bad { color:#b00020; }

      @media (max-width: 900px) {
        :root { --top-h: 28vh; --bottom-h: 28vh; }
        .charts { grid-template-rows: var(--top-h) var(--top-h) var(--bottom-h);
                  grid-template-columns: 1fr; }
        .top-left  { grid-row: 1; grid-column: 1; }
        .top-right { grid-row: 2; grid-column: 1; }
        .bottom    { grid-row: 3; grid-column: 1; }
      }
    </style>
  </head>
  <body>
    <div class="layout">
      <div class="header">
        <div>
          <h1>Event Hubs (Kafka) Metrics</h1>
          <div class="muted">Polling <code>/metrics</code> every 3s • Delay = time from Produced to same Processed count</div>
        </div>
        <div class="controls">
          <label for="baselineTime" class="muted">Baseline time (today):</label>
          <input id="baselineTime" type="time" step="60" />
          <button id="setBaseline" class="btn">Set baseline</button>
          <button id="clearBaseline" class="btn">Clear</button>
          <span id="baselineBadge" class="badge muted">No baseline</span>
        </div>
      </div>

      <div class="charts">
        <div class="card top-left">
          <div class="status" id="status-pp">—</div>
          <h3 class="title">Processed vs Produced</h3>
          <div class="wrap"><canvas id="ppChart"></canvas></div>
        </div>

        <div class="card top-right">
          <div class="status" id="status-delay">—</div>
          <h3 class="title">Watermark Delay (Produced → Processed at same count)</h3>
          <div class="wrap"><canvas id="delayChart"></canvas></div>
        </div>

        <div class="card bottom">
          <div class="status" id="status-lag">—</div>
          <h3 class="title">Total Lag</h3>
          <div class="wrap"><canvas id="lagChart"></canvas></div>
        </div>
      </div>
    </div>

    <script>
      const COLORS = {
        blue:   '#1f77b4',
        purple: '#6f42c1',
        teal:   '#17a2b8',
        orange: '#ff7f0e',
        grid:   '#d7d7d7',
        ticks:  '#333',
        axes:   '#bdbdbd'
      };

      const MAX_POINTS = 180; // keep last N points (lower = faster)
      const commonOpts = {
        animation: false,
        responsive: true,
        maintainAspectRatio: false,
        interaction: { mode: 'index', intersect: false },
        plugins: {
          legend: { position: 'top', labels: { color: COLORS.ticks, font: { weight: '600' } } },
          tooltip: { mode: 'index', intersect: false },
          decimation: { enabled: true, algorithm: 'lttb', samples: MAX_POINTS }
        },
        scales: {
          x: { ticks: { color: COLORS.ticks, maxTicksLimit: 6 }, grid: { color: COLORS.grid }, border: { color: COLORS.axes } }
        },
        elements: { line: { borderWidth: 2, tension: 0.2, borderCapStyle: 'round' }, point:{ radius: 0, hoverRadius: 2 } }
      };

      const ppChart = new Chart(document.getElementById('ppChart').getContext('2d'), {
        type: 'line',
        data: { labels: [], datasets: [
          { label: 'Processed Total (rebased)', data: [], borderColor: COLORS.purple, pointRadius: 0 },
          { label: 'Produced  Total (rebased)', data: [], borderColor: COLORS.blue,   pointRadius: 0 }
        ]},
        options: { ...commonOpts, scales: { ...commonOpts.scales, y: { beginAtZero: true, ticks:{ color: COLORS.ticks, callback: v => v.toLocaleString() }, grid:{ color: COLORS.grid }, border:{ color: COLORS.axes } } } }
      });

      const delayChart = new Chart(document.getElementById('delayChart').getContext('2d'), {
        type: 'line',
        data: { labels: [], datasets: [{ label: 'Delay (s)', data: [], borderColor: COLORS.orange, pointRadius: 0 }] },
        options: { ...commonOpts, scales: { ...commonOpts.scales, y: { beginAtZero: true, ticks:{ color: COLORS.ticks }, grid:{ color: COLORS.grid }, border:{ color: COLORS.axes } } } }
      });

      const lagChart = new Chart(document.getElementById('lagChart').getContext('2d'), {
        type: 'line',
        data: { labels: [], datasets: [{ label: 'Total Lag (rebased)', data: [], borderColor: COLORS.teal, pointRadius: 0 }] },
        options: { ...commonOpts, scales: { ...commonOpts.scales, y: { ticks:{ color: COLORS.ticks, callback: v => v.toLocaleString() }, grid:{ color: COLORS.grid }, border:{ color: COLORS.axes } } } }
      });

      const ppStatus    = document.getElementById('status-pp');
      const delayStatus = document.getElementById('status-delay');
      const lagStatus   = document.getElementById('status-lag');

      // Baseline controls
      const baselineInput = document.getElementById('baselineTime');
      const setBtn = document.getElementById('setBaseline');
      const clearBtn = document.getElementById('clearBaseline');
      const badge = document.getElementById('baselineBadge');

      let baselineTimeMs = null, baselineActive = false;
      let baseProcessed = null, baseProduced = null, baseLag = null;

      function setBadge(text){ badge.textContent = text; }
      function computeTodayTimeMs(hhmm){ const [h,m]=hhmm.split(':').map(Number); const d=new Date(); return new Date(d.getFullYear(),d.getMonth(),d.getDate(),h,m,0,0).getTime(); }

      setBtn.onclick = () => {
        const val = baselineInput.value;
        baselineTimeMs = val ? computeTodayTimeMs(val) : Date.now();
        baselineActive = false;
        baseProcessed = baseProduced = baseLag = null;
        setBadge(val ? `Baseline set: ${new Date(baselineTimeMs).toLocaleTimeString()}` : 'Baseline: now');
        // Reset series so rebasing is instant and cheap
        producedSeries.length = 0; processedSeries.length = 0; prodCursor = 0;
        delayChart.data.labels = []; delayChart.data.datasets[0].data = [];
      };
      clearBtn.onclick = () => {
        baselineTimeMs = null; baselineActive=false;
        baseProcessed = baseProduced = baseLag = null;
        setBadge('No baseline');
        producedSeries.length = 0; processedSeries.length = 0; prodCursor = 0;
        delayChart.data.labels = []; delayChart.data.datasets[0].data = [];
      };

      // --- FAST delay computation state ---
      // We store the rebased cumulative series with timestamps.
      const producedSeries  = []; // [{t:number, v:number}]
      const processedSeries = []; // (we push for completeness; not used for search now)
      let prodCursor = 0;         // advancing cursor in producedSeries for level search

      function pushSeries(arr, t, v){
        arr.push({ t, v });
        if (arr.length > MAX_POINTS) {
          arr.shift();
          // Adjust cursor if it fell off the front
          if (arr === producedSeries && prodCursor > 0) prodCursor--;
        }
      }

      // Find time when produced first reaches 'level' using a rolling cursor.
      function timeProducedAtLevel(level){
        const arr = producedSeries;
        if (!arr.length) return null;
        // Advance cursor until v >= level (monotonic series expected)
        while (prodCursor < arr.length && arr[prodCursor].v < level) prodCursor++;
        if (prodCursor >= arr.length) return null; // not reached yet
        if (arr[prodCursor].v === level || prodCursor === 0) return arr[prodCursor].t;
        const a = arr[prodCursor - 1], b = arr[prodCursor];
        const dv = b.v - a.v;
        if (dv <= 0) return b.t; // flat or duplicate
        const frac = (level - a.v) / dv;
        return a.t + frac * (b.t - a.t);
      }

      async function tick() {
        try {
          const res = await fetch('/metrics', { cache: 'no-store' });
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const m = await res.json();

          const now = new Date();
          const nowMs = now.getTime();
          const label = now.toLocaleTimeString();
          const statusText = `Updated ${label}`;
          [ppStatus, delayStatus, lagStatus].forEach(el => { el.textContent = statusText; el.classList.remove('bad'); });

          // Activate baseline when time passes
          if (baselineTimeMs !== null && !baselineActive && nowMs >= baselineTimeMs) {
            baseProcessed = m.processedTotal ?? 0;
            baseProduced  = m.endTotal ?? 0;
            baseLag       = m.totalLag ?? 0;
            baselineActive = true;
            setBadge(`Baseline active: ${new Date(baselineTimeMs).toLocaleTimeString()}`);
            // Reset series so levels start from ~0
            producedSeries.length = 0; processedSeries.length = 0; prodCursor = 0;
            delayChart.data.labels = []; delayChart.data.datasets[0].data = [];
          }

          // Rebased values (>= 0)
          const processedRe = Math.max(0, (m.processedTotal ?? 0) - (baselineActive ? baseProcessed : 0));
          const producedRe  = Math.max(0, (m.endTotal      ?? 0) - (baselineActive ? baseProduced  : 0));
          const lagRe       = Math.max(0, (m.totalLag      ?? 0) - (baselineActive ? baseLag       : 0));

          // Handle resets (drop in totals)
          const lastP = producedSeries.length ? producedSeries[producedSeries.length-1].v : null;
          const lastC = processedSeries.length ? processedSeries[processedSeries.length-1].v : null;
          if ((lastP !== null && producedRe  < lastP) || (lastC !== null && processedRe < lastC)) {
            producedSeries.length = 0; processedSeries.length = 0; prodCursor = 0;
            delayChart.data.labels = []; delayChart.data.datasets[0].data = [];
          }

          // Update top-left cumulative chart
          ppChart.data.labels.push(label);
          ppChart.data.datasets[0].data.push(processedRe);
          ppChart.data.datasets[1].data.push(producedRe);
          if (ppChart.data.labels.length > MAX_POINTS) {
            ppChart.data.labels.shift();
            ppChart.data.datasets.forEach(d => d.data.shift());
          }

          // Update series for delay calc (O(1) amortized)
          pushSeries(producedSeries,  nowMs, producedRe);
          pushSeries(processedSeries, nowMs, processedRe);

          // Compute delay quickly:
          // time when produced reached current processed count vs now
          let delaySec = null;
          const tProd = timeProducedAtLevel(processedRe);
          if (tProd != null) delaySec = Math.max(0, (nowMs - tProd) / 1000);

          // Update delay chart
          delayChart.data.labels.push(label);
          delayChart.data.datasets[0].data.push(delaySec);
          if (delayChart.data.labels.length > MAX_POINTS) {
            delayChart.data.labels.shift();
            delayChart.data.datasets[0].data.shift();
          }

          // Update lag chart
          lagChart.data.labels.push(label);
          lagChart.data.datasets[0].data.push(lagRe);
          if (lagChart.data.labels.length > MAX_POINTS) {
            lagChart.data.labels.shift();
            lagChart.data.datasets[0].data.shift();
          }

          // Commit all paint operations in one go
          ppChart.update('none');
          delayChart.update('none');
          lagChart.update('none');

        } catch (e) {
          const msg = `Error: ${e.message}`;
          [ppStatus, delayStatus, lagStatus].forEach(el => { el.textContent = msg; el.classList.add('bad'); });
          console.error(e);
        }
      }

      tick();
      setInterval(tick, 3000);
    </script>
  </body>
</html>

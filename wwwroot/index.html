<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Event Hubs (Kafka) Lag</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
      * { box-sizing: border-box; }
      html, body { height: 100%; }
      body { margin: 12px; overflow: hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial; color:#111; background:#fff; }

      .layout { height: 100%; display: flex; flex-direction: column; gap: 8px; }
      h1 { margin: 0; font-size: 18px; font-weight: 700; }
      .muted { color:#666; font-size:12px; }

      .cards { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px,1fr)); gap: 8px; }
      .card { padding: 8px; border: 1px solid #e2e2e2; border-radius: 10px; background:#fff; }
      .label { color:#666; font-size:11px; text-transform: uppercase; letter-spacing:.08em; }
      .kpi { font-size: 20px; font-weight: 800; }

      /* Three charts without vertical scroll: two on top, one full-width below */
      :root { --chart-h-top: 26vh; --chart-h-bottom: 20vh; }
      .charts { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
      .charts2 { display: grid; grid-template-columns: 1fr; gap: 8px; }
      .chart-card { border: 1px solid #e2e2e2; border-radius: 10px; padding: 8px; background:#fff; position: relative; }
      .chart-title { margin: 0 0 4px 0; font-size: 14px; font-weight: 700; }
      .chart-sub { margin: -2px 0 6px; color:#666; font-size:12px; }
      .chart-wrap.top { height: var(--chart-h-top); }
      .chart-wrap.bottom { height: var(--chart-h-bottom); }
      .chart-wrap canvas { width: 100%; height: 100%; display:block; }

      .status { position:absolute; top:8px; right:10px; font-size:11px; color:#666; }
      .status.bad { color:#b00020; }

      @media (max-width: 900px) {
        :root { --chart-h-top: 22vh; --chart-h-bottom: 22vh; }
        .charts { grid-template-columns: 1fr; }
      }
    </style>
  </head>
  <body>
    <div class="layout">
      <div>
        <h1>Event Hubs Lag (Kafka consumer)</h1>
        <div class="muted">Polling <code>/metrics</code> every 3s</div>
      </div>

      <div class="cards">
        <div class="card"><div class="label">Total Lag</div><div id="lag" class="kpi">–</div></div>
        <div class="card"><div class="label">Processed Total</div><div id="processed" class="kpi">–</div></div>
        <div class="card"><div class="label">Produced Total</div><div id="produced" class="kpi">–</div></div>
        <div class="card"><div class="label">Watermark Delay (max)</div><div id="delayMax" class="kpi">–</div></div>
        <div class="card"><div class="label">Topic / Group</div><div class="kpi"><span id="topic">–</span> / <span id="cg">–</span></div></div>
      </div>

      <div class="charts">
        <div class="chart-card">
          <div class="status" id="status-lag">—</div>
          <h3 class="chart-title">Total Lag</h3>
          <div class="chart-wrap top"><canvas id="lagChart"></canvas></div>
        </div>
        <div class="chart-card">
          <div class="status" id="status-rate">—</div>
          <h3 class="chart-title">Processed vs Produced</h3>
          <div class="chart-sub">Instantaneous rate (events/sec)</div>
          <div class="chart-wrap top"><canvas id="ppChart"></canvas></div>
        </div>
      </div>

      <div class="charts2">
        <div class="chart-card">
          <div class="status" id="status-delay">—</div>
          <h3 class="chart-title">Watermark Delay</h3>
          <div class="chart-sub">Max delay across partitions (seconds)</div>
          <div class="chart-wrap bottom"><canvas id="delayChart"></canvas></div>
        </div>
      </div>
    </div>

    <script>
      const COLORS = {
        blue:   '#1f77b4', // produced rate
        purple: '#6f42c1', // processed rate
        teal:   '#17a2b8', // lag
        orange: '#ff7f0e', // delay
        grid:   '#d7d7d7',
        ticks:  '#333',
        axes:   '#bdbdbd'
      };
      const fmt = n => Number(n ?? 0).toLocaleString();

      // KPI elements
      const lagEl = document.getElementById('lag');
      const procEl = document.getElementById('processed');
      const prodEl = document.getElementById('produced');
      const delayMaxEl = document.getElementById('delayMax');
      const topicEl = document.getElementById('topic');
      const cgEl = document.getElementById('cg');

      // Status labels
      const lagStatus   = document.getElementById('status-lag');
      const rateStatus  = document.getElementById('status-rate');
      const delayStatus = document.getElementById('status-delay');

      const commonOpts = {
        animation: false,
        responsive: true,
        maintainAspectRatio: false,
        interaction: { mode: 'index', intersect: false },
        plugins: {
          legend: { position: 'top', labels: { color: COLORS.ticks, font: { weight: '600' } } },
          tooltip: { mode: 'index', intersect: false }
        },
        scales: {
          x: { ticks: { color: COLORS.ticks, maxTicksLimit: 10 }, grid: { color: COLORS.grid }, border: { color: COLORS.axes } }
        },
        elements: { line: { borderWidth: 3, tension: 0.25, borderCapStyle: 'round' }, point:{ radius: 0, hoverRadius: 3 } }
      };

      // Lag chart
      const lagChart = new Chart(document.getElementById('lagChart').getContext('2d'), {
        type: 'line',
        data: { labels: [], datasets: [{ label: 'Total Lag', data: [], borderColor: COLORS.teal }] },
        options: { ...commonOpts, scales: { ...commonOpts.scales, y: { ticks: { color: COLORS.ticks, callback: v => v.toLocaleString() }, grid:{ color: COLORS.grid }, border:{ color: COLORS.axes } } } }
      });

      // Rate chart (instantaneous)
      const ppChart = new Chart(document.getElementById('ppChart').getContext('2d'), {
        type: 'line',
        data: { labels: [], datasets: [
          { label: 'Processed (events/sec)', data: [], borderColor: COLORS.purple },
          { label: 'Produced  (events/sec)', data: [], borderColor: COLORS.blue }
        ]},
        options: { ...commonOpts, scales: { ...commonOpts.scales, y: { beginAtZero: true, ticks:{ color: COLORS.ticks, callback: v => v.toLocaleString() }, grid:{ color: COLORS.grid }, border:{ color: COLORS.axes } } } }
      });

      // Watermark delay chart (seconds)
      const delayChart = new Chart(document.getElementById('delayChart').getContext('2d'), {
        type: 'line',
        data: { labels: [], datasets: [{ label: 'Max Delay (s)', data: [], borderColor: COLORS.orange }] },
        options: { ...commonOpts, scales: { ...commonOpts.scales, y: { beginAtZero: true, ticks:{ color: COLORS.ticks }, grid:{ color: COLORS.grid }, border:{ color: COLORS.axes } } } }
      });

      // For rate calculation
      let prevProcessed = null, prevProduced = null, prevTs = null;

      async function tick() {
        try {
          const res = await fetch('/metrics', { cache: 'no-store' });
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const m = await res.json();

          const now = new Date();
          const nowLabel = now.toLocaleTimeString();
          const statusText = `Updated ${nowLabel}`;
          [lagStatus, rateStatus, delayStatus].forEach(el => { el.textContent = statusText; el.classList.remove('bad'); });

          // KPIs
          lagEl.textContent = fmt(m.totalLag);
          procEl.textContent = fmt(m.processedTotal);
          prodEl.textContent = fmt(m.endTotal);
          delayMaxEl.textContent = `${Math.round((m.watermarkDelayMsMax ?? 0) / 1000)}s`;
          topicEl.textContent = m.topic ?? '–';
          cgEl.textContent = m.consumerGroup ?? '–';

          // Chart 1: Lag
          lagChart.data.labels.push(nowLabel);
          lagChart.data.datasets[0].data.push(m.totalLag ?? 0);
          if (lagChart.data.labels.length > 240) { lagChart.data.labels.shift(); lagChart.data.datasets[0].data.shift(); }
          lagChart.update('none');

          // Chart 2: Instantaneous rates
          const nowTs = Date.now();
          if (prevProcessed !== null && prevProduced !== null && prevTs !== null) {
            const dtSec = Math.max(0.001, (nowTs - prevTs) / 1000);
            let dProc = (m.processedTotal ?? 0) - prevProcessed;
            let dProd = (m.endTotal ?? 0) - prevProduced;
            if (dProc < 0) dProc = 0;   // guard resets/rewinds
            if (dProd < 0) dProd = 0;

            const rateProc = dProc / dtSec;
            const rateProd = dProd / dtSec;

            ppChart.data.labels.push(nowLabel);
            ppChart.data.datasets[0].data.push(rateProc);
            ppChart.data.datasets[1].data.push(rateProd);
            if (ppChart.data.labels.length > 240) {
              ppChart.data.labels.shift();
              ppChart.data.datasets.forEach(d => d.data.shift());
            }
            ppChart.update('none');
          }
          prevProcessed = m.processedTotal ?? 0;
          prevProduced  = m.endTotal ?? 0;
          prevTs        = nowTs;

          // Chart 3: Watermark delay (max across partitions, seconds)
          const delaySec = (m.watermarkDelayMsMax ?? 0) / 1000.0;
          delayChart.data.labels.push(nowLabel);
          delayChart.data.datasets[0].data.push(delaySec);
          if (delayChart.data.labels.length > 240) { delayChart.data.labels.shift(); delayChart.data.datasets[0].data.shift(); }
          delayChart.update('none');

        } catch (e) {
          console.error('metrics fetch failed:', e);
          const msg = `Error: ${e.message}`;
          [lagStatus, rateStatus, delayStatus].forEach(el => { el.textContent = msg; el.classList.add('bad'); });
        }
      }

      tick();
      setInterval(tick, 3000);
    </script>
  </body>
</html>
